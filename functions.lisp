(progn
  (set 'mapcar (lambda '(f l) '(if l (cons (f (car l)) (recurse f (cdr l))))))
  (set 'reduce (lambda '(f l) `(,(lambda '(f l a) '(if (null l) a (recurse f (cdr l) (f a (car l)))))
				 f (cdr (cdr l)) (f (car l) (car (cdr l))))))
  (set 'range (lambda '(stt stp end) '(if (or (and (> stt end) (> stp 0)) (and (< stt end) (< stp 0))) nil
					(cons stt (recurse (+ stt stp) stp end)))))
  (set 'desc (lambda '(o l) '(cond ((null o) l)
				   ((eq (car o) 'a) (recurse (cdr o) (car l)))
				   ((eq (car o) 'd) (recurse (cdr o) (cdr l)))
				   (t (recurse (cdr o) l)))))
  (set 'nth (lambda '(n l) '(if (> n 0) (recurse (- n 1) (cdr l)) (car l))))
  (set 'apply (lambda '(f l) '(uplevel 1 `(,f @l))))
  (set 'zip (lambda '(a b) '(if (or (null a) (null b)) nil
			      (cons (cons (car a) (car b)) (recurse (cdr a) (cdr b))))))
  (set 'flatten (lambda '(l) '(cond ((null l) nil)
				    ((atom l) (cons l nil))
				    (t (nconc (recurse (car l)) (recurse (cdr l)))))))
  (set 'time (lambda '(expr times) '(progn (tick)
					   (for '(set 'i 0) '(< i times) '(+= 'i 1) expr)
					   (/ (tock) times))))
  (set 'assoc (lambda '(s l) '(cond ((null l) nil)
				    ((eq (car (car l)) s) (car l))
				    (t (assoc s (cdr l))))))
  (set 'reverse (lambda '(l) '(if (null (cdr l)) l
				(nconc (recurse (cdr l)) (cons (car l) nil)))))
  (set 'while (lambda '(c b) '(uplevel 1 `(for nil (quote ,c) nil (quote ,b)))))
  (set 'do (lambda '(b while c) '(uplevel 1 `(progn ,b (,while (quote ,c) (quote ,b))))))
  (set 'lis2arr (lambda '(l) '(progn (set 'n (length l)) (set 'a (array n))
				     (for '(set 'i 0) '(< i n) '(+= 'i 1)
					  '(progn (aset a i (car l)) (set 'l (cdr l))))
				     a)))
  (set 'lrepeat (lambda '(n x) '(progn (set 'l nil)
				       (for nil '(> n 0) '(set 'n (- n 1))
					    '(set 'l (cons x l)))
				       l)))
  t)
