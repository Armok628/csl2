(progn
  (set 'mapcar (lambda '(f l) '(if l (cons (f (car l)) (recurse f (cdr l))))))
  (set 'reduce (lambda '(f l) `(if (cdr l)
				 (,(lambda '(f l a) '(if (null l) a (recurse f (cdr l) (f a (car l)))))
				   f (cdr (cdr l)) (f (car l) (car (cdr l))))
				 (car l))))
  (set 'range (lambda '(stt stp end) '(if (or (and (> stt end) (> stp 0)) (and (< stt end) (< stp 0))) nil
					(cons stt (recurse (+ stt stp) stp end)))))
  (set 'desc (lambda '(o l) '(cond ((null o) l)
				   ((eq (car o) 'a) (recurse (cdr o) (car l)))
				   ((eq (car o) 'd) (recurse (cdr o) (cdr l)))
				   (t (recurse (cdr o) l)))))
  (set 'nth (lambda '(n l) '(if (> n 0) (recurse (- n 1) (cdr l)) (car l))))
  (set 'randelt (lambda '(l) '(nth (random (length l)) l)))
  (set 'zip (lambda '(a b) '(if (or (null a) (null b)) nil
			      (cons (cons (car a) (car b)) (recurse (cdr a) (cdr b))))))
  (set 'flatten (lambda '(l) '(cond ((null l) nil)
				    ((atom l) (cons l nil))
				    (t (nconc (recurse (car l)) (recurse (cdr l)))))))
  (set 'time (lambda '(expr times) '(progn (tick)
					   (for '(set 'i 0) '(< i times) '(+= 'i 1) expr)
					   (/ (tock) times))))
  (set 'assoc (lambda '(s l) '(cond ((null l) nil)
				    ((eq (car (car l)) s) (car l))
				    (t (assoc s (cdr l))))))
  (set 'reverse (lambda '(l) '(if (null (cdr l)) l
				(nconc (recurse (cdr l)) (cons (car l) nil)))))
  (set 'while (lambda '(c b) '(uplevel 1 `(for nil (quote ,c) nil (quote ,b)))))
  (set 'until (lambda '(c b) '(uplevel 1 `(for nil (quote (not ,c)) nil (quote ,b)))))
  (set 'do (lambda '(b while c) '(uplevel 1 `(progn ,b (,while (quote ,c) (quote ,b))))))
  (set 'repeat (lambda '(n a) '(if (> n 0) (cons a (recurse (- n 1) a)))))
  (set 'max (lambda '(x y) '(if (> x y) x y)))
  (set 'min (lambda '(x y) '(if (< x y) x y)))
  (set 'equal (lambda '(a b) '(if (and (not (atom a)) (not (atom b)))
				(and (recurse (car a) (car b)) (recurse (cdr a) (cdr b)))
				(eq a b))))
  (set 'search (lambda '(f l) '(cond ((atom l) nil)
				     ((f (car l)) '(a))
				     ((f (cdr l)) '(d))
				     ((set 'y (recurse f (car l))) (cons 'a y))
				     ((set 'y (recurse f (cdr l))) (cons 'd y)))))
  t)
